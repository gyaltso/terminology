/*
* generated by Xtext
*/
package de.itemis.tooling.terminology.ui.outline;

import java.util.List;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.AbstractOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;

import de.itemis.tooling.terminology.terminology.Entry;
import de.itemis.tooling.terminology.terminology.Language;
import de.itemis.tooling.terminology.terminology.SubjectEntries;
import de.itemis.tooling.terminology.terminology.Term;
import de.itemis.tooling.terminology.terminology.Terminology;

/**
 * customization of the default outline structure
 * 
 */
public class TerminologyOutlineTreeProvider extends DefaultOutlineTreeProvider {

	protected boolean _isLeaf(Term modelElement) {
		return true;
	}

	@Override
	protected void _createChildren(final DocumentRootNode parentNode,
			EObject modelElement) {
		if(modelElement instanceof SubjectEntries){
			final SubjectEntries entries = (SubjectEntries)modelElement;
			final EList<Language> languages;
			try {
				languages = ((Terminology) entries.getSubject().eContainer()).getLanguages();
			} catch (NullPointerException e) {
				new AbstractOutlineNode(parentNode,null,"No outline available. Make sure,",true) {};
				new AbstractOutlineNode(parentNode,null,"the project has the Xtext nature and",true) {};
				new AbstractOutlineNode(parentNode,null,"start a clean build.",true) {};
				return;
			}
			createLanguageNodes(parentNode, entries, languages);
		}
	}

	void createLanguageNodes(IOutlineNode parent, final SubjectEntries entries, final EList<Language> languages){
		for (final Language language : languages) {
			new AbstractOutlineNode(parent,null,language.getId(),false) {
				boolean created=false;
				@Override
				public List<IOutlineNode> getChildren() {
					if(!created){
							createLanguageChildren(this, language, entries);
						}
						created=true;
					return super.getChildren();
				}
			};
		}
	}

	private void createLanguageChildren(IOutlineNode parentNode, Language language,
			SubjectEntries entries) {
		for (Entry entry: entries.getEntries()) {
			for (Term term: entry.getTerms()) {
				if(term.getLanguage()==language){
					super.createEObjectNode(parentNode, term);
				}
			}
		}
	}
}
